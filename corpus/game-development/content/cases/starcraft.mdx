---
id: starcraft
title: 스타크래프트
description: RTS, 락스텝과 완벽한 동기화

genre: RTS
year: 1998
keyFeatures:
  - 완벽한 동기화
  - 락스텝 네트워킹
  - 리플레이

fundamentals:
  - modeling-simulation
  - networking

decisions:
  - sync-strategy
  - tickrate

demos:
  - lockstep

exportable:
  web: true
  blog: true
  resume: false
---

# 스타크래프트

RTS 장르의 정점, 락스텝 동기화의 교과서.

## 기술적 도전

1998년, 28.8kbps 모뎀이 주류였던 시대. 수백 개의 유닛을 어떻게 실시간으로 동기화할 수 있었을까?

### 문제 상황

- **대역폭 제한**: 28.8kbps = 초당 3.6KB 전송 가능
- **유닛 수**: 한 경기에 수백 개의 유닛이 동시에 존재
- **동기화 요구**: 모든 플레이어가 정확히 같은 게임 상태를 봐야 함

## 해결책: 락스텝 네트워킹

### 핵심 아이디어

> "유닛의 상태를 전송하지 말고, 입력만 전송하자"

각 클라이언트가 동일한 결정론적 시뮬레이션을 실행하면, 같은 입력에서 같은 결과가 나온다.

### 구현 방식

1. **입력 수집**: 플레이어의 모든 명령을 수집
2. **입력 공유**: 모든 플레이어에게 입력을 브로드캐스트
3. **동시 실행**: 모든 클라이언트가 같은 틱에 같은 입력을 처리
4. **결정론 보장**: 부동소수점 대신 고정소수점, 정렬된 컨테이너 사용

### 장점

- **대역폭 효율**: 유닛 상태 대신 입력만 전송 (수 KB vs 수백 바이트)
- **리플레이**: 입력 시퀀스만 저장하면 전체 게임 재현 가능
- **치트 감지**: 시뮬레이션 결과 비교로 탐지

### 단점

- **입력 지연**: 모든 플레이어의 입력을 기다려야 함
- **재연결 불가**: 도중 참여 시 처음부터 시뮬레이션 재실행 필요
- **결정론 유지 어려움**: 모든 연산이 완전히 동일해야 함

## 왜 락스텝인가?

| 대안 | 문제점 |
|------|--------|
| State Sync | 대역폭 폭발 (수백 유닛 × 상태) |
| Client-Server | 서버 인프라 비용, 중앙 집중 실패점 |
| Client Prediction | RTS에서 복잡한 롤백 필요 |

락스텝은 1998년 환경에서 최적의 선택이었다.

## 참고 자료

- [1500 Archers on a 28.8 - Age of Empires Postmortem](https://www.gamedeveloper.com/programming/1500-archers-on-a-28-8-network-programming-in-age-of-empires)
- [Gaffer On Games: Deterministic Lockstep](https://gafferongames.com/post/deterministic_lockstep/)
